import { c as create_ssr_component } from "./index.js";
const metadata = {
  "id": "0021",
  "title": "Plutus on-chain",
  "date": "2022-07-01",
  "categories": ["Plutus", "Cardano"]
};
const _0021 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<h2 id="${"plutus-on-chain-code"}"><a aria-hidden="${"true"}" tabindex="${"-1"}" href="${"#plutus-on-chain-code"}"><span class="${"icon icon-link"}"></span></a>Plutus On-chain code</h2>
<ul><li><code>BuiltinData</code> -&gt; low-level data type. Cheaper and better performance (this is the level that plutarch works on).<ul><li>The reason for this low-level data types is that they align well with Plutus Core and on-chain code gets transpiled into Plutus Core (lambda calculus bytecode that goes into the blockchain) at <strong>compile time</strong>.</li>
<li>Everything in the on-chain code needs to ‚Äúfit‚Äù into <code>BuiltinData</code>, if it‚Äôs more complex, it will eventually need to be reduced to <code>BuiltinData</code><ul><li>You can wrap it <strong>on-chain</strong> -&gt; expensive</li>
<li>You can wrap it <strong>off-chain</strong> -&gt; arbitrary</li></ul></li></ul></li></ul>
<p>This üëá is the code that <strong>validates</strong> or not the tx i.e, if the utxos can or cannot be consumed:</p>
<pre class="${"language-haskell"}"><!-- HTML_TAG_START -->${`<code class="language-haskell"><span class="token comment">&#123;-# INLINABLE alwaysSucceeds #-&#125;</span>
<span class="token hvariable">alwaysSucceeds</span> <span class="token operator">::</span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">alwaysSucceeds</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">&#123;-# INLINABLE alwaysFails #-&#125;</span>
<span class="token hvariable">alwaysFails</span> <span class="token operator">::</span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token constant">BuiltinData</span> <span class="token hvariable">_</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">alwaysFails</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token punctuation">(</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<ul><li><p>These are the <strong>conditions</strong> the transaction <strong>must meet</strong> in order for the utxos to be <strong>consumed</strong>.</p></li>
<li><p><code>{-# LANGUAGE TemplateHaskell #-}</code> is a Haskell compiler extension, it allows you to do one thing:</p>
<ul><li>Plutus only uses certain parts of the libraries that it is importing.</li>
<li>In the case of <code>TemplateHaskell</code>, Plutus uses it to <strong>generate code at compile time</strong>.</li></ul></li></ul>
<pre class="${"language-haskell"}"><!-- HTML_TAG_START -->${`<code class="language-haskell"><span class="token hvariable">validator</span> <span class="token operator">::</span> <span class="token constant">Validator</span>
<span class="token hvariable">validator</span> <span class="token operator">=</span> <span class="token hvariable">mkValidatorScript</span> <span class="token operator">$$</span><span class="token punctuation">(</span><span class="token hvariable">PlutusTx<span class="token punctuation">.</span>compile</span> <span class="token punctuation">[</span><span class="token operator">||</span> <span class="token hvariable">goodRedeemer</span> <span class="token operator">||</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>In order for this üëÜ to be INLINABLE, you need to include the INLINABLE pragma <code>{-# INLINABLE goodRedeemer #-}</code></p>
<h2 id="${"defining-the-goodredeemer"}"><a aria-hidden="${"true"}" tabindex="${"-1"}" href="${"#defining-the-goodredeemer"}"><span class="${"icon icon-link"}"></span></a>Defining the <code>goodRedeemer</code></h2>
<pre class="${"language-haskell"}"><!-- HTML_TAG_START -->${`<code class="language-haskell"><span class="token comment">&#123;-# INLINABLE goodRedeemer #-&#125;</span>
<span class="token hvariable">goodRedeemer</span> <span class="token operator">::</span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">goodRedeemer</span> <span class="token hvariable">_</span> <span class="token hvariable">redeemer</span> <span class="token hvariable">_</span> 
  <span class="token operator">|</span> <span class="token hvariable">redeemer</span> <span class="token operator">==</span> <span class="token hvariable">Builtins<span class="token punctuation">.</span>mkI</span> <span class="token number">42</span>         <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span>              <span class="token operator">=</span> <span class="token hvariable">traceError</span> <span class="token string">"Wrong Redeemer!"</span>
</code>`}<!-- HTML_TAG_END --></pre>
<ul><li>This üëÜ <code>goodRedeemer</code> will <strong>succeed</strong> if the value <code>42</code> is provided and <strong>fail</strong> <code>otherwise</code>.</li>
<li>The <code>goodRedeemer</code> function cares <strong>only</strong> about the <code>redeemer</code>.</li></ul>
<h3 id="${"why-use-template-haskell-and-inlinable-pragmas"}"><a aria-hidden="${"true"}" tabindex="${"-1"}" href="${"#why-use-template-haskell-and-inlinable-pragmas"}"><span class="${"icon icon-link"}"></span></a>Why use template Haskell and <code>INLINABLE</code> pragmas?</h3>
<ul><li>To increase modularity and maintanability, i.e.,</li></ul>
<pre class="${"language-haskell"}"><!-- HTML_TAG_START -->${`<code class="language-haskell">  <span class="token hvariable">validator</span> <span class="token operator">::</span> <span class="token constant">Validator</span>
  <span class="token hvariable">validator</span> <span class="token operator">=</span> <span class="token hvariable">mkValidatorScript</span> <span class="token operator">$$</span><span class="token punctuation">(</span><span class="token hvariable">PlutusTx<span class="token punctuation">.</span>compile</span> <span class="token punctuation">[</span><span class="token operator">||</span> <span class="token hvariable">goodRedeemer</span> <span class="token operator">::</span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
                                                        <span class="token hvariable">goodRedeemer</span> <span class="token hvariable">_</span> <span class="token hvariable">redeemer</span> <span class="token hvariable">_</span> 
                                                          <span class="token operator">|</span> <span class="token hvariable">redeemer</span> <span class="token operator">==</span> <span class="token hvariable">Builtins<span class="token punctuation">.</span>mkI</span> <span class="token number">42</span>         <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
                                                          <span class="token operator">|</span> <span class="token builtin">otherwise</span>              <span class="token operator">=</span> <span class="token hvariable">traceError</span> <span class="token string">"Wrong Redeemer!"</span> <span class="token operator">||</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<ul><li>üëÜ This is going to be a pain to maintain.</li></ul>
<pre class="${"language-haskell"}"><!-- HTML_TAG_START -->${`<code class="language-haskell"><span class="token comment">&#123;-# INLINABLE goodRedeemer #-&#125;</span>
<span class="token hvariable">goodRedeemer</span> <span class="token operator">::</span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token constant">BuiltinData</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">goodRedeemer</span> <span class="token hvariable">_</span> <span class="token hvariable">redeemer</span> <span class="token hvariable">_</span> 
  <span class="token operator">|</span> <span class="token hvariable">redeemer</span> <span class="token operator">==</span> <span class="token hvariable">Builtins<span class="token punctuation">.</span>mkI</span> <span class="token number">42</span>         <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span>              <span class="token operator">=</span> <span class="token hvariable">traceError</span> "<span class="token constant">Wrong</span> <span class="token constant">Redeemer</span><span class="token operator">!</span>
<span class="token hvariable">validator</span> <span class="token operator">::</span> <span class="token constant">Validator</span>
<span class="token hvariable">validator</span> <span class="token operator">=</span> <span class="token hvariable">mkValidatorScript</span> <span class="token operator">$$</span><span class="token punctuation">(</span><span class="token hvariable">PlutusTx<span class="token punctuation">.</span>compile</span> <span class="token punctuation">[</span><span class="token operator">||</span> <span class="token hvariable">goodRedeemer</span> <span class="token operator">||</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<ul><li><p>Whereas this üëÜ, will allow us to update <code>goodRedeemer</code> without modifying the <code>validator</code> (it‚Äôs also more readable).</p></li>
<li><p>The <code>Builtins.mkI</code> is a necessary wrapper function that turns the <code>Int</code> type into a <code>BuiltinData</code> type. The <code>I</code> is the constructor inside <code>BuiltinData</code> for <strong>integer</strong> values, not <strong>floats</strong>.</p></li></ul>
<h3 id="${"what-does-the-template-haskell-do-exactly"}"><a aria-hidden="${"true"}" tabindex="${"-1"}" href="${"#what-does-the-template-haskell-do-exactly"}"><span class="${"icon icon-link"}"></span></a>What does the template Haskell do exactly?</h3>
<ul><li>It takes the <code>goodRedeemer</code> function and generates the Plutus Core script code that goes into the blokchain.</li>
<li>In order to do that, all data types and functions <strong>must be</strong> <code>INLINABLE</code>, that is why plutus has its own prelude library (<code>PlutusTx.Prelude</code>), it includes the <code>INLINABLE</code> versions of the <strong>basic functions</strong> (not all, it is a <em>subset</em> of prelude) of prelude in Haskell.</li></ul>
<h3 id="${"valhash"}"><a aria-hidden="${"true"}" tabindex="${"-1"}" href="${"#valhash"}"><span class="${"icon icon-link"}"></span></a><code>valHash</code></h3>
<pre class="${"language-haskell"}"><!-- HTML_TAG_START -->${`<code class="language-haskell"><span class="token hvariable">valHash</span> <span class="token operator">::</span> <span class="token constant">Ledger<span class="token punctuation">.</span>ValidatorHash</span>
<span class="token hvariable">valHash</span> <span class="token operator">=</span> <span class="token hvariable">Script<span class="token punctuation">.</span>validatorHash</span> <span class="token hvariable">validator</span>

<span class="token hvariable">scrAddress</span> <span class="token operator">::</span> <span class="token constant">Ledger<span class="token punctuation">.</span>Address</span>
<span class="token hvariable">scrAddress</span> <span class="token operator">=</span> <span class="token hvariable">scriptAddress</span> <span class="token hvariable">validator</span></code>`}<!-- HTML_TAG_END --></pre>
<ul><li>In this case, the <code>Script</code> in the <code>valHash</code> function is calling the high-level type of <code>Script</code>, however it‚Äôs name doesn‚Äôt change. This will happen often as is designed to avoid rewriting too much code when making changes. This way, you can jump from a high to a low level or vice versa without changing all of the code because the functions will be calling the same <strong>if you are using the same qualifier</strong> (What is a qualifier? Which is the qualifier in this case?)</li></ul>
<h2 id="${"function-evaluations"}"><a aria-hidden="${"true"}" tabindex="${"-1"}" href="${"#function-evaluations"}"><span class="${"icon icon-link"}"></span></a>Function evaluations</h2>
<ul><li><code>goodRedeemer</code> -&gt; <code>Validator { &lt;script&gt; }</code> -&gt; This is the compiled validator (in Plutus Core) and it is wrapped by the <code>Validator</code> data type.</li>
<li><code>valHash</code> -&gt; <code>78947563cd8s97c7d0as9d7as8s00s9d8lalk3j3</code></li>
<li><code>scrAddress</code> -&gt; <code>Address { addressCredential = ScriptCredential 78947563cd8s97c7d0as9d7as8s00s9d8lalk3j3, addressStakingCredential = Nothing }</code></li></ul>
<p>This is generated by template Haskell at compile time, and it allows us to use it, not as Haskell code, but Plutus Core script that you can keep in your code in some way (i.e., the <code>Validator {&lt;script&gt;</code>, the <code>valHash</code>, and the <code>scrAddress</code>}), in this case, to be used in the <strong>off-chain</strong> code.</p>
<h2 id="${"the-last-validator"}"><a aria-hidden="${"true"}" tabindex="${"-1"}" href="${"#the-last-validator"}"><span class="${"icon icon-link"}"></span></a>The last validator</h2>
<p>The contract has no more utxo, but someone must pay the fees. So the wallet that is doing the grabbing gets provided a utxo that is used to pay the fees and give back change because the contract has no value. This implies you need to verify <strong>off-chain</strong> if you can actually do the transaction because you have the utxos necessary. If not, it should fail to avoid the expenditure of fees.</p>
<h3 id="${"fun-fact"}"><a aria-hidden="${"true"}" tabindex="${"-1"}" href="${"#fun-fact"}"><span class="${"icon icon-link"}"></span></a>Fun fact</h3>
<p>The reason you ‚Äòwait‚Äô in the Plutus Playground is to simulate the passage of time. Due to the asynchronicity of the blockchain (is this a word?), there is no guarantee that the giving and the grabbing will happen at a predetermined order, so time for settlements must be provided.</p>`;
});
export {
  _0021 as default,
  metadata
};
